package main

import (
	"context"
	"math/rand"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// функция воркер, нужна для имитации работы
func worker(ctx context.Context, wg *sync.WaitGroup) {
	// уменьшаем счётчик вэйт группы (-1)
	defer wg.Done()

	for {
		select {
		// когда мы в main() отменим наш контекс, то ctx.Done() вернёт закрытый канал
		// чтение из закрытого канала - nil значение, следовательно проваливаемся в этот кейс и делаем return
		case <-ctx.Done():
			return
		// по дефолту имитируем работу воркера
		default:
			time.Sleep(time.Duration(rand.Intn(5)) * time.Second)
		}
	}
}

func main() {
	// создаем канал с отменой
	// context.Background() - пэрент контекст
	ctx, cancel := context.WithCancel(context.Background())
	// казалось бы, мы же делаем отмену контекста ниже, зачем нам отменять контекст еще и через отложенный вызов (defer)
	// между отменой контекста ниже и созданием контекста могут быть какие либо условия, которые могут завершать нашу программу
	// отложенным вызовом завершения контекста мы гарантируем освобождение ресурсов
	defer cancel()

	// вейт группа, необходима для того, чтобы дождаться выполнения всех горутин
	wg := &sync.WaitGroup{}

	// создаем 5 воркеров
	for range 5 {
		// увеличиваем счетчик воркеров на 1
		wg.Add(1)
		go worker(ctx, wg)
	}

	// создаем буф канал для получения системных сигналов
	sigCh := make(chan os.Signal, 1)

	// подписываемся каналом sigCh на сигнала SIGINT (CTRL + C) и SIGTERM
	// эти сигналы будут отправлены в канал sigCh вместо стандартных обработчиков гошного рантайма
	// но может возникнуть вопрос: подписываемся на сигнал SIGINT, а в функцию мы передали os.Interrupt, почему?
	// это сделано для обеспечения кроссплотформенности, чтобы и на Windows и на Unix-подобных системах os.Interrupt преобразовывался в конкретный сигнал
	// под копотом в Go os Interrupt это: var Interrupt = sysyscall.SIGINT (пакет os)
	signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

	// чтение из канала - блокирующая операция, поэтому на этом этапе блокируем наш main до момента
	// пока не получим сигнал завершения
	<-sigCh

	// отменяем наш контекст, тем самым останавливаем работу всех воркеров
	cancel()

	// дожидаемся завершения всех горутин
	wg.Wait()
}
